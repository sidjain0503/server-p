"""
Product API routes

This module contains CUSTOM product-related API endpoints for business logic.
The standard CRUD operations are auto-generated by the meta-engine.
"""

from typing import List, Optional
from fastapi import APIRouter, HTTPException, Depends, Path, Body, status
from fastapi.responses import JSONResponse
from sqlalchemy.ext.asyncio import AsyncSession
from pydantic import BaseModel, Field

from app.api.v1.dependencies import (
    DatabaseSession, get_crud_service,
    get_pagination_params, get_search_params
)
from app.meta_engine.orchestrator import get_meta_engine
from app.meta_engine.crud_service import QueryParams
from app.services.security import get_current_user, get_optional_user, User

# Create router for custom product endpoints
router = APIRouter()

# Get the CRUD service for products
get_product_crud = get_crud_service("Product")


# =============================================================================
# Custom Business Logic Routes (CRUD routes are auto-generated)
# =============================================================================

class ProductAnalyticsResponse(BaseModel):
    """Product analytics response model"""
    product_id: int
    total_views: int = Field(..., description="Total product views")
    total_sales: int = Field(..., description="Total sales count")
    popularity_score: float = Field(..., description="Popularity score (0-10)")
    trending: bool = Field(..., description="Whether product is trending")
    revenue: float = Field(..., description="Total revenue generated")


class InventoryUpdateRequest(BaseModel):
    """Inventory update request model"""
    quantity_change: int = Field(..., description="Quantity change (positive or negative)")
    reason: str = Field("manual_adjustment", description="Reason for inventory change")


class ProductDuplicationResponse(BaseModel):
    """Product duplication response model"""
    message: str
    original_id: int
    new_id: int
    new_name: str


@router.get("/{product_id}/analytics", response_model=ProductAnalyticsResponse, summary="Get Product Analytics - PROTECTED")
async def get_product_analytics(
    db: DatabaseSession,
    crud_service = Depends(get_product_crud),
    product_id: int = Path(..., description="Product ID"),
    current_user: User = Depends(get_current_user)  # PROTECTED: Only authenticated users can see analytics
):
    """Get detailed analytics and performance metrics for a product - REQUIRES AUTHENTICATION"""
    try:
        product = await crud_service.get(db, product_id)
        if not product:
            raise HTTPException(status_code=404, detail="Product not found")
        
        # Mock analytics data - in real app, this would come from analytics service
        analytics = ProductAnalyticsResponse(
            product_id=product_id,
            total_views=1250 + (product_id * 47),  # Mock data based on ID
            total_sales=87 + (product_id * 12),
            popularity_score=min(10.0, 8.5 + (product_id * 0.1)),
            trending=bool(product_id % 3 == 0),  # Every 3rd product is trending
            revenue=float(product.price * (87 + (product_id * 12)))
        )
        
        return analytics
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.put("/{product_id}/inventory", summary="Update Product Inventory - PROTECTED")
async def update_inventory(
    db: DatabaseSession,
    crud_service = Depends(get_product_crud),
    product_id: int = Path(..., description="Product ID"),
    request: InventoryUpdateRequest = Body(...),
    current_user: User = Depends(get_current_user)  # PROTECTED: Only authenticated users can update inventory
):
    """Update product inventory with quantity changes and tracking - REQUIRES AUTHENTICATION"""
    try:
        product = await crud_service.get(db, product_id)
        if not product:
            raise HTTPException(status_code=404, detail="Product not found")
        
        # Calculate new quantity
        new_quantity = product.stock_quantity + request.quantity_change
        if new_quantity < 0:
            raise HTTPException(
                status_code=400, 
                detail="Insufficient inventory. Cannot reduce below 0."
            )
        
        # Update product with new inventory
        updated_product = await crud_service.update(db, product_id, {
            "stock_quantity": new_quantity,
            "in_stock": new_quantity > 0
        })
        
        return JSONResponse(
            status_code=200,
            content={
                "message": "Inventory updated successfully",
                "product_id": product_id,
                "old_quantity": product.stock_quantity,
                "new_quantity": new_quantity,
                "change": request.quantity_change,
                "reason": request.reason,
                "in_stock": new_quantity > 0
            }
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/{product_id}/duplicate", response_model=ProductDuplicationResponse, summary="Duplicate Product - PROTECTED")
async def duplicate_product(
    db: DatabaseSession,
    crud_service = Depends(get_product_crud),
    product_id: int = Path(..., description="Product ID to duplicate"),
    current_user: User = Depends(get_current_user)  # PROTECTED: Only authenticated users can duplicate products
):
    """Create a duplicate product for A/B testing or variations - REQUIRES AUTHENTICATION"""
    try:
        original = await crud_service.get(db, product_id)
        if not original:
            raise HTTPException(status_code=404, detail="Product not found")
        
        # Create duplicate with modified data
        duplicate_data = {
            "name": f"{original.name} (Copy)",
            "description": original.description,
            "price": original.price,
            "category": original.category,
            "tags": original.tags,
            "in_stock": False,  # Start as out of stock
            "stock_quantity": 0,
            "image_url": original.image_url
        }
        
        new_product = await crud_service.create(db, duplicate_data)
        
        return ProductDuplicationResponse(
            message="Product duplicated successfully",
            original_id=product_id,
            new_id=new_product.id,
            new_name=duplicate_data["name"]
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/category/{category}", summary="Get Products by Category - PUBLIC")
async def get_products_by_category(
    db: DatabaseSession,
    crud_service = Depends(get_product_crud),
    pagination = Depends(get_pagination_params),
    category: str = Path(..., description="Product category")
    # PUBLIC: No authentication required - anyone can browse products by category
):
    """Get all products in a specific category - PUBLIC ROUTE"""
    try:
        query_params = QueryParams(
            skip=pagination.skip,
            limit=pagination.limit,
            filters={"category": category}
        )
        products = await crud_service.list(db, query_params)
        return products
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/low-stock", summary="Get Low Stock Products - PUBLIC")
async def get_low_stock_products(
    db: DatabaseSession,
    crud_service = Depends(get_product_crud),
    pagination = Depends(get_pagination_params),
    threshold: int = 10
    # PUBLIC: No authentication required - anyone can see low stock products
):
    """Get products with low stock levels - PUBLIC ROUTE"""
    try:
        query_params = QueryParams(
            skip=pagination.skip,
            limit=pagination.limit,
            filters={"stock_quantity__lte": threshold}
        )
        products = await crud_service.list(db, query_params)
        return products
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e)) 