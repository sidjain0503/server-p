"""
Generic CRUD Service

This module provides universal CRUD operations that work with any dynamically
created model. It handles validation, permissions, and all standard database
operations in a generic way.
"""

from typing import Any, Dict, List, Optional, Type, Union
from datetime import datetime

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, delete, func, and_, or_
from sqlalchemy.exc import IntegrityError
from pydantic import BaseModel, ValidationError

from app.models.base import DynamicModel
from app.meta_engine.schema_definition import SchemaDefinition, FieldDefinition, PermissionLevel


class CRUDException(Exception):
    """Base exception for CRUD operations."""
    pass


class ValidationException(CRUDException):
    """Raised when validation fails."""
    pass


class PermissionException(CRUDException):
    """Raised when permission check fails."""
    pass


class NotFoundException(CRUDException):
    """Raised when record is not found."""
    pass


class QueryParams(BaseModel):
    """Parameters for querying records."""
    
    # Pagination
    skip: int = 0
    limit: int = 100
    
    # Sorting
    order_by: Optional[str] = None
    order_desc: bool = False
    
    # Filtering
    filters: Optional[Dict[str, Any]] = None
    search: Optional[str] = None
    search_fields: Optional[List[str]] = None
    
    # Soft delete
    include_deleted: bool = False


class GenericCRUDService:
    """
    Generic CRUD service that works with any dynamic model.
    
    This service provides standard database operations (Create, Read, Update, Delete)
    that work with any model generated by our meta-engine. It handles:
    - Data validation
    - Permission checking
    - Soft delete
    - Audit trails
    - Search and filtering
    - Pagination
    """
    
    def __init__(self, model: Type[DynamicModel], schema: SchemaDefinition):
        self.model = model
        self.schema = schema
        self._validate_model_schema_compatibility()
    
    def _validate_model_schema_compatibility(self):
        """Ensure the model and schema are compatible."""
        if not hasattr(self.model, '_schema_name'):
            raise CRUDException("Model does not appear to be a dynamic model")
        
        if self.model._schema_name != self.schema.name:
            raise CRUDException(
                f"Model schema name '{self.model._schema_name}' "
                f"does not match provided schema '{self.schema.name}'"
            )
    
    async def create(
        self, 
        session: AsyncSession, 
        data: Dict[str, Any], 
        created_by_id: Optional[int] = None
    ) -> DynamicModel:
        """
        Create a new record.
        
        Args:
            session: Database session
            data: Record data
            created_by_id: ID of user creating the record
            
        Returns:
            Created model instance
        """
        # Validate input data
        validated_data = self._validate_create_data(data)
        
        # Check create permissions
        self._check_create_permissions(validated_data, created_by_id)
        
        # Create model instance
        instance = self.model(**validated_data)
        
        # Set audit fields if available
        if hasattr(instance, 'created_by_id') and created_by_id:
            instance.created_by_id = created_by_id
        
        try:
            session.add(instance)
            await session.commit()
            await session.refresh(instance)
            return instance
            
        except IntegrityError as e:
            await session.rollback()
            raise ValidationException(f"Data integrity error: {str(e)}")
    
    async def get(
        self, 
        session: AsyncSession, 
        record_id: int, 
        user_id: Optional[int] = None
    ) -> Optional[DynamicModel]:
        """
        Get a record by ID.
        
        Args:
            session: Database session
            record_id: Record ID
            user_id: ID of user requesting the record
            
        Returns:
            Model instance or None if not found
        """
        query = select(self.model).where(self.model.id == record_id)
        
        # Apply soft delete filter
        if hasattr(self.model, 'is_deleted'):
            query = query.where(self.model.is_deleted == False)
        
        result = await session.execute(query)
        instance = result.scalar_one_or_none()
        
        if instance:
            # Check read permissions
            self._check_read_permissions(instance, user_id)
        
        return instance
    
    async def list(
        self, 
        session: AsyncSession, 
        params: QueryParams, 
        user_id: Optional[int] = None
    ) -> List[DynamicModel]:
        """
        List records with filtering, searching, and pagination.
        
        Args:
            session: Database session
            params: Query parameters
            user_id: ID of user requesting the records
            
        Returns:
            List of model instances
        """
        query = select(self.model)
        
        # Apply soft delete filter
        if hasattr(self.model, 'is_deleted') and not params.include_deleted:
            query = query.where(self.model.is_deleted == False)
        
        # Apply filters
        if params.filters:
            query = self._apply_filters(query, params.filters)
        
        # Apply search
        if params.search and params.search_fields:
            query = self._apply_search(query, params.search, params.search_fields)
        
        # Apply ordering
        if params.order_by:
            query = self._apply_ordering(query, params.order_by, params.order_desc)
        
        # Apply pagination
        query = query.offset(params.skip).limit(params.limit)
        
        result = await session.execute(query)
        instances = result.scalars().all()
        
        # Check read permissions for each instance
        filtered_instances = []
        for instance in instances:
            try:
                self._check_read_permissions(instance, user_id)
                filtered_instances.append(instance)
            except PermissionException:
                continue  # Skip records user can't read
        
        return filtered_instances
    
    async def count(
        self, 
        session: AsyncSession, 
        params: QueryParams, 
        user_id: Optional[int] = None
    ) -> int:
        """
        Count records matching the query parameters.
        
        Args:
            session: Database session
            params: Query parameters
            user_id: ID of user requesting the count
            
        Returns:
            Number of matching records
        """
        query = select(func.count(self.model.id))
        
        # Apply soft delete filter
        if hasattr(self.model, 'is_deleted') and not params.include_deleted:
            query = query.where(self.model.is_deleted == False)
        
        # Apply filters
        if params.filters:
            query = self._apply_filters(query, params.filters)
        
        # Apply search
        if params.search and params.search_fields:
            query = self._apply_search(query, params.search, params.search_fields)
        
        result = await session.execute(query)
        return result.scalar()
    
    async def update(
        self, 
        session: AsyncSession, 
        record_id: int, 
        data: Dict[str, Any], 
        updated_by_id: Optional[int] = None
    ) -> Optional[DynamicModel]:
        """
        Update a record.
        
        Args:
            session: Database session
            record_id: Record ID to update
            data: Updated data
            updated_by_id: ID of user updating the record
            
        Returns:
            Updated model instance or None if not found
        """
        # Get existing record
        instance = await self.get(session, record_id, updated_by_id)
        if not instance:
            return None
        
        # Check update permissions
        self._check_update_permissions(instance, updated_by_id)
        
        # Validate update data
        validated_data = self._validate_update_data(data, instance)
        
        # Update fields
        for field, value in validated_data.items():
            setattr(instance, field, value)
        
        # Set audit fields if available
        if hasattr(instance, 'updated_by_id') and updated_by_id:
            instance.updated_by_id = updated_by_id
        
        try:
            await session.commit()
            await session.refresh(instance)
            return instance
            
        except IntegrityError as e:
            await session.rollback()
            raise ValidationException(f"Data integrity error: {str(e)}")
    
    async def delete(
        self, 
        session: AsyncSession, 
        record_id: int, 
        deleted_by_id: Optional[int] = None,
        hard_delete: bool = False
    ) -> bool:
        """
        Delete a record (soft or hard delete).
        
        Args:
            session: Database session
            record_id: Record ID to delete
            deleted_by_id: ID of user deleting the record
            hard_delete: Whether to permanently delete the record
            
        Returns:
            True if deleted, False if not found
        """
        # Get existing record
        instance = await self.get(session, record_id, deleted_by_id)
        if not instance:
            return False
        
        # Check delete permissions
        self._check_delete_permissions(instance, deleted_by_id)
        
        if hard_delete or not hasattr(instance, 'soft_delete'):
            # Hard delete
            await session.delete(instance)
        else:
            # Soft delete
            instance.soft_delete(deleted_by_id)
        
        await session.commit()
        return True
    
    def _validate_create_data(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Validate data for creating a new record."""
        validated_data = {}
        
        # Check required fields
        required_fields = self.schema.get_required_fields()
        for field in required_fields:
            if field.name not in data:
                raise ValidationException(f"Required field '{field.name}' is missing")
        
        # Validate each field
        for field in self.schema.fields:
            if field.name in data:
                value = data[field.name]
                validated_value = self._validate_field_value(field, value)
                validated_data[field.name] = validated_value
        
        return validated_data
    
    def _validate_update_data(self, data: Dict[str, Any], instance: DynamicModel) -> Dict[str, Any]:
        """Validate data for updating an existing record."""
        validated_data = {}
        
        # Validate each field in the update data
        for field_name, value in data.items():
            field = self.schema.get_field(field_name)
            if field:
                validated_value = self._validate_field_value(field, value)
                validated_data[field_name] = validated_value
            else:
                # Allow updating system fields like metadata
                if field_name in ['metadata_json', 'tags']:
                    validated_data[field_name] = value
        
        return validated_data
    
    def _validate_field_value(self, field: FieldDefinition, value: Any) -> Any:
        """Validate a single field value."""
        # This is a simplified validation - in a full system,
        # you'd use the validation rules from the field definition
        
        if value is None and field.required:
            raise ValidationException(f"Field '{field.name}' is required")
        
        if value is None:
            return None
        
        # Type validation would go here
        # Length validation would go here
        # Choice validation would go here
        # Custom validation rules would go here
        
        return value
    
    def _check_create_permissions(self, data: Dict[str, Any], user_id: Optional[int]):
        """Check if user can create a record with this data."""
        # This is a simplified permission check
        # In a full system, you'd implement comprehensive permission logic
        pass
    
    def _check_read_permissions(self, instance: DynamicModel, user_id: Optional[int]):
        """Check if user can read this record."""
        # This is a simplified permission check
        # In a full system, you'd implement comprehensive permission logic
        pass
    
    def _check_update_permissions(self, instance: DynamicModel, user_id: Optional[int]):
        """Check if user can update this record."""
        # This is a simplified permission check
        # In a full system, you'd implement comprehensive permission logic
        pass
    
    def _check_delete_permissions(self, instance: DynamicModel, user_id: Optional[int]):
        """Check if user can delete this record."""
        # This is a simplified permission check
        # In a full system, you'd implement comprehensive permission logic
        pass
    
    def _apply_filters(self, query, filters: Dict[str, Any]):
        """Apply filters to the query."""
        for field_name, value in filters.items():
            if hasattr(self.model, field_name):
                column = getattr(self.model, field_name)
                if isinstance(value, list):
                    query = query.where(column.in_(value))
                else:
                    query = query.where(column == value)
        return query
    
    def _apply_search(self, query, search_term: str, search_fields: List[str]):
        """Apply text search to the query."""
        conditions = []
        for field_name in search_fields:
            if hasattr(self.model, field_name):
                column = getattr(self.model, field_name)
                conditions.append(column.ilike(f"%{search_term}%"))
        
        if conditions:
            query = query.where(or_(*conditions))
        
        return query
    
    def _apply_ordering(self, query, order_by: str, desc: bool):
        """Apply ordering to the query."""
        if hasattr(self.model, order_by):
            column = getattr(self.model, order_by)
            if desc:
                query = query.order_by(column.desc())
            else:
                query = query.order_by(column.asc())
        return query 